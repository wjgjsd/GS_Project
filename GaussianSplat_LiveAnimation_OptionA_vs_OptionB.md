# 가우시안 스플랫 실시간 데이터 변경 (Live Animation) 아키텍처 비교 가이드

가우시안 스플래팅 씬에서 30fps로 10초간 부드러운 애니메이션을 보여주거나, 네트워크를 통해 들어오는 실시간 데이터 스트리밍을 렌더링에 반영할 때는 크게 두 가지 접근 방식이 있습니다. 이 문서는 두 방식의 작동 원리와 장단점, 왜 Option B가 그래픽스 업계 표준인지 상세히 서술합니다.

---

## [옵션 A] 원본 버퍼 영구 덮어쓰기 (Compute Shader Overwrite)
이 방식은 앞서 우리가 `SplatUtilities.compute`의 `CSApplyDelta`에서 가장 처음 시도했던 직관적이고 하드코어한 방식입니다.

### ⚙️ 작동 원리 (Mechanism)
1. 외부 C# 스크립트가 "몇 번 가우시안을 이만큼 X,Y 스케일로 옮겨라" 라는 오프셋(Delta) 정보를 담은 소형 구조체 버퍼를 작성해 GPU의 **Compute Shader(연산 전용 다목적 셰이더)** 로 보냅니다.
2. 매 프레임 Compute Shader가 가동되어, 현재 GPU 메모리에 단단히 고정되어 올라가 있는 수십 기가바이트의 **'메인 원본 버퍼(`_SplatPos`)'의 자물쇠를 강제로 엽니다.**
3. 그 안의 고도로 압축된 바이너리(`Norm11` 등) 값을 CPU처럼 직접 수식 계산하여 압축을 풀고(Decode), 오프셋 숫자를 더한 뒤, **다시 원래의 `Norm11` 청크 박스 포맷으로 억지로 꽉꽉 눌러 재압축(Encode)하여 메인 버퍼가 위치한 원래 메모리 주소에 아예 영구적으로 덮어씌워 버립니다.**

### 🟢 장점
- 원본 데이터 모델 자체가 메모리 안에서 완전히 새 수치로 덮어씌워져 바뀌기 때문에 구조 파악이 매우 단순하고 직관적입니다. (마치 C#에서 List의 값을 덮어쓰는 것과 같은 느낌)
- 렌더링을 담당하는 셰이더(`GaussianSplatting.hlsl`) 쪽은 전혀 건드릴 필요 없이 순정 상태를 유지합니다.

### 🔴 치명적 단점 (Glitch Maker)
1. **바둑판 청크 글리치 결함:** 가우시안 데이터는 용량을 위해 `256개 단위의 청크 바운딩 박스`로 한계 공간을 좁게 구획하여 0~1 비율로 저장(`Norm11`)합니다. Compute Shader가 메인 메모리를 덮어쓸 때, 만약 사용자가 지정한 이동의 폭이 그 가상의 박스 한계치(1.0)를 넘어가게 되면 **GPU는 가차 없이 값을 최대치인 1.0으로 잘라버립니다 (Clamp 현상).** 이로 인해 스플랫들이 각자가 태어난 보이지 않는 투명한 큐브 유리벽에 쿵 부딪혀 납작하게 찌그러지는 치명적인 바둑판 글리치가 필연적으로 발생합니다.
2. **읽기/쓰기 성능의 병목 한계:** 수백만 개의 점을 초당 30번씩 압축 풀기 ➡ 공간 수식 계산 ➡ 재압축 ➡ 메모리 덮어쓰기를 무식하게 반복하는 것은 엄청난 GPU 연산 부하(I/O Bottle Neck)를 만듭니다.
3. **색상(Color) 텍스처 접근 거부:** 메모리 내의 위치나 물리적 성질 버퍼는 배열(Buffer)이라 억지로 덮어쓸 수 있지만, 색상 버퍼(`m_GpuColorData`)는 시스템이 렌더링에 최적화된 완전히 잠긴 **읽기 전용 이미지(`Texture2D`)로 취급해 생성**해 둡니다. 이를 매 프레임 Compute Shader로 억지로 덮어쓰려면(Random Write `UAV` 접근 권한 부여), 가우시안 렌더러의 코어 에셋 생성 파이프라인 전체를 박살 내고 새로 설계해야 하는 막대한 대공사가 수반됩니다.

---

## [옵션 B] 무손실 라이브 델타 버퍼 주입 (Live Delta Buffer Injection) - 🔥 적극 권장 방식
이 방식은 수천만 개의 폴리곤을 매 프레임 흔들어야 하는 최신 AAA 게임 엔진들이나, 캐릭터 스키닝(Skinning) 본 애니메이션에서 밥 먹듯이 사용하는 업계 표준이자, 우리가 방금 `GaussianLiveAnimator`로 성공적으로 구현해 낸 매우 우아한 방식입니다.

### ⚙️ 작동 원리 (Mechanism)
1. `GaussianSplatRenderer`가 우주가 시작될 때, 수백만 개의 스플랫 갯수만큼 방을 가지되 **값은 전부 무해한 기본값 (위치 오프셋은 +0, 스케일 증폭은 x1, 색상은 투명한 흰색 틴트 x1)으로 꽉 비어있는 가벼운 투명 필터 "라이브 델타 버퍼(`_LivePosScaleDelta`, `_LiveColorOpacDelta`)"**를 GPU 메모리 위에 한 겹 새롭게 할당합니다.
2. 외부 애니메이터 시뮬레이터(`GaussianLiveAnimator.cs`)는 유니티의 답답하고 손상되기 쉬운 원본 압축 데이터는 거들떠보지도 않고, 오직 C# CPU 단에서 이 빠르고 가벼운 텅텅 빈 델타 버퍼 위에다가 30fps 속도로 **"532번 스플랫 위치는 +0.02 이동, 533번 색상은 빨간색 틴트로 덮어"**라는 부가적인 수학적 이동 지시사항 부호만 실시간으로 경쾌하게 덮어씁니다.
3. 가장 마지막에 화면을 시각적으로 모니터에 송출하기 나노초 직전, 렌더링 셰이더(`GaussianSplatting.hlsl`)가 화면의 픽셀을 칠하려고 원본 압축(`Norm11`, 텍스처 등)을 찰흙처럼 깔끔하게 **다 풀어헤쳐놓은 매우 쾌적한 가상의 스크래치 패드 상태(`float3` 실수 상태)**에 들어섰을 때, **"어? 오늘 아침에 투명 델타 버퍼에 적힌 지시사항이 있네? 거기에 맞춰서 살짝 더해서 최종 도화지에 그려줄게!"** 라며 단 1줄의 덧셈/곱셈 연산 부호만 거친 뒤에 최종 화면으로 출력합니다.

### 🟢 압도적인 장점 (Flawless Architecture)
1. **무한한 조작의 자유 (글리치 해방):** 원본 데이터 압축(`Norm11`) 시스템은 단 1비트의 손상도 입지 않은 채 신성한 유물처럼 하드 보호됩니다. 압축이 이미 완전히 다 풀려 물리적인 3D 월드 공간의 무한한 축척으로 환산된 실수(float) 좌표에다가 그저 오프셋을 살짝 더하는 것이기 때문에, **아무리 멀리 우주 바깥 1억km 밖으로 지정한 스플랫 무리를 이동시키고 크기를 10,000배로 키워도 절대 박스 경계에 부딪혀 찌그러지는 현상(Clamp)이 생기지 않습니다!** 완벽하게 매끄러운 궤적 렌더링이 이루어집니다.
2. **미친듯한 가벼움과 실시간 속도:** C#에서 50,000개 이상의 배열 요소에 수학적 증감 팩터를 계산해 매 프레임 부어넣더라도, 구조가 너무 가볍고 머리를 쥐어뜯는 재압축 부담이 전혀 없기 때문에 모바일 기기에서도 손쉽게 60fps로 실시간 애니메이션 할 수 있습니다. `Compute Shader`의 커다랗고 무거운 실행 파이프라인 엔진조차 아예 켤 필요가 없습니다. (그래서 코드가 매우 간결해집니다)
3. **비파괴적 파이프라인 (Non-Destructive):** 애니메이터 끄기 버튼을 누르거나, 델타 버퍼에 값을 전부 +0으로 리셋하는 명령을 보내는 순간 바로 다음 1밀리초 만에 원래의 구겨짐 없는 정상적인 원본 씬으로 돌아옵니다.
4. **색상과 투명도까지 자유자재로 해방:** 압축된 읽기 전용 `Texture2D` 이미지라는 한계에 전혀 부딪히지 않고, 머리를 굴릴 필요도 없습니다. 어차피 렌더러가 화면을 뿌리기 나노초 직전에 float 스크래치 변수 위에서 순수 Color 수학 RGB 값에 곱셈만 탁! 쳐주면 끝이기 때문입니다.

### 🔴 유일한 성질의 차이점 (단점 아님)
- **영구 기록이 불가능함:** 라이브 델타 버퍼 방식은 화면 위 렌즈에 덧대진 투명 색안경 셀로판지 필터 연산(Live Effect) 같은 역할입니다. 이 애니메이션이 끝난 최종 이동 상태 *그대로를 영원히 박제하여* 하드웨어 깊숙이 새로운 정적 `.asset` 파일로 남기고 싶다면, 이 실시간 렌더링 뷰파인더 정보만으로는 불가능합니다. 그 목적이라면 지난번에 우리가 창조했던 오프라인 '에디터 스크립트 툴 구조(위치 변경 버튼 툴)'를 이용해 기나긴 압축 및 청크 재분할 굽기 인고의 시간을 견뎌내며 새 유니티 에셋을 창조해야만 합니다. (하지만 유저님이 제안하신 '실시간 정보 연동 라이브 스트리밍' 목적이라면 애초에 에셋을 박제 저장할 이유가 없으므로 완벽하게 일치하는 솔루션입니다.)

---

### 🔥 최종 두 줄 요약 비교 
* **옵션 A (Compute Shader 버퍼 강제 조작):** "낡고 예민한 원본 설계도면(압축파일)을 매 프레임마다 지우개로 빡빡 지우고 다른 위치로 고쳐 써서 다시 억지로 좁은 상자에 쑤셔넣어 보관함에 넣는 고문 방식." (연산 성능이 크게 박살나고, 비좁은 박스 한계를 벗어나면 데이터가 오그라들어 글리치가 생김)
* **옵션 B (무손실 라이브 델타 조명 주입):** "귀중한 원본 유물은 깔끔한 박물관 유리 책상 밑에 고스란히 영원히 보호하고, 그 위 투명한 필터 공간 상에서 조명의 각도나 이동 레이저 지시사항만 재빠르게 바꿔 비춰서 수백만 개의 점들이 생생하게 살아서 이동하고 춤추게 보여주는 업계 그래픽 엔진 표준 애니메이션 방식." (버벅임이 없고, 글리치 없이 이동에 한계 벽이 존재하지 않음)
