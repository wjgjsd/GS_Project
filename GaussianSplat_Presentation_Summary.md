# 가우시안 스플래팅 유니티 파이프라인 및 실시간 렌더링 라이브 애니메이션 연구 결과

본 문서는 사내/외부 발표 자료 준비를 위해 그동안 진행한 `.ply` 포맷의 유니티 렌더링 아키텍처 과정, 시행착오, 그리고 완성된 최종 애니메이션 시스템(Live Animation)의 원리와 결과를 요약한 기술 문서입니다.

---

## 1. 개요: `.ply` 가우시안 스플랫의 유니티 렌더링 파이프라인

수 기가바이트(GB)에 달하는 방대한 구름 형태의 3D 데이터인 `.ply` 파일을 유니티에서 60fps로 실시간 렌더링하기 위해서는 가공 없는 원본 파싱(Direct Rendering) 방식이 아닌, **"공간 정렬 및 양자화 압축(Quantization)"**을 거친 유니티 전용 `.asset` 변환 파이프라인이 필수적입니다.

### ⚙️ 에셋 변환 핵심 프로세스 (PLY to Asset)
1. **모튼 정렬(Morton Reordering):** 물리적으로 가까운 가우시안 점(Splat)들을 메모리 배열 상에서도 인접하게 위치하도록 3D 공간 스캐닝 곡선 단위로 재정렬하여 GPU 캐시 성능을 극대화합니다.
2. **청크 단위 분할(Chunking):** 256개 단위로 점들을 묶어, 해당 그룹을 꽉 채우는 타이트한 투명 바운딩 박스를 치고, 거대한 단위의 3D 월드 좌표에서 그 좁은 박스 내부의 0.0 ~ 1.0 상대 비율(비율 좌표) 값으로 수치를 깎습니다.
3. **극한의 양자화 압축(Norm11 & 작은 각도 압축):** 비율로 깎인 데이터는 단 32비트(4바이트) 정수 공간 안에 X, Y, Z 세 축을 구겨 넣는(11, 10, 11 구조) 극한 압축을 거칩니다. 색상 처리 역시 막대한 용량을 줄이기 위해 대표 색상들을 머신러닝(K-Means)으로 군집화하고 번호표(Texture2D 형태)만 붙여 관리합니다.
4. **.asset 생성:** 쪼개어진 위치 구조, 회전 및 크기, 컬러 속성을 유니티 `ScriptableObject` 에셋으로 도장 찍어 완성합니다.

📌 **결론:** 유니티 렌더링은 위 과정을 거쳐 고도로 뭉쳐지고 박스 안에 갇힌 **"읽기 전용 암호화 압축 텍스처"**를 스크래치 패드(GPU)에 올려 실시간으로 압축을 풀며 그림을 그립니다.

---

## 2. 시행착오 (Trials & Errors): 라이브 애니메이션의 함정

사용자가 요구한 "방대한 가우시안 스플랫들을 씬 내에서 실시간으로 이동시키고 애니메이션을 부여하는 기능"을 개발하는 단계에서 두 가지 주요 접근 방식과 기술적 한계를 마주했습니다.

### 🚨 [옵션 A] Compute Shader를 통한 원본 버퍼 조작 시도 (실패 및 대형 글리치 발생)
초기에는 아주 직관적인 방식, 즉 **GPU 메모리에 올라간 메인 원본 배열(`_SplatPos`)의 압축을 Compute Shader로 직접 풀어서 이동 좌표를 더한 뒤, 다시 재압축하여 덮어쓰는 구조**를 채택했습니다. 하지만 이는 곧 막대한 글리치를 일으켰습니다.

#### ❌ 문제점: 바둑판 글리치 현상 (Clamp Limitation)
* **박스 충돌 현상:** 앞서 에셋 압축 단계에서 각 점은 256개 단위의 투명한 `청크 박스 비율(0~1)`에 갇혀버렸습니다. 애니메이션을 주고자 1.0(박스 최대치) 밖으로 좌표를 강제 이동시킬 경우, **유니티가 시스템 한계상 강제로 최대치 1.0으로 좌표를 잘라버립니다 (Clamp).**
* 그 결과, 넓은 우주로 날아가야 할 점들이 자신이 갇힌 256개의 투명한 유리벽 모서리에 부딪혀 찌그러지는 **"바둑판 모양의 심각한 시각적 글리치"**가 발생했습니다.
* **성능 부하 및 색상 변경 불가:** 매 프레임 수백만 개의 점을 다시 압축하는 것은 огромный GPU 병목을 일으켰으며, 더 최악인 점은 색상(Color) 데이터가 완벽히 잠긴 이미지 형태(`Texture2D`)로 올라가 있어 아예 접근 및 수정 권한(`UAV`)조차 부여할 수 없었습니다.

---

## 3. 돌파 및 현재 상태: 무손실 라이브 델타 주입 아키텍처 (Option B)

글리치 없이 유연한 모바일/PC 60fps 애니메이션 송출을 위해 최신 그래픽스 업계 표준 방식인 **"라이브 델타 주입(Live Delta Injection)"** 구조를 채택하여 성공적으로 구현했습니다.

### ✅ 새로운 아키텍처: `GaussianLiveAnimator` 시스템 구축
이 방식은 앞선 "에셋 덮어쓰기"나 "재압축" 같은 비효율적 수단을 아예 배제합니다.

1. **투명 델타 버퍼 할당:** `GaussianSplatRenderer` 내부에 값은 모두 빈 기본값(+0 이동, x1 배율, 투명 색상)으로 비워진 극도로 가벼운 "라이브 지시사항 메모장 버퍼(`_LivePosScaleDelta`, `_LiveColorOpacDelta`)"를 할당합니다.
2. **C# 오프셋 통신:** 유니티의 애니메이터(CPU)가 수천수만 개의 점들에 대한 "상대적인 이동 지시사항 부호"만 프레임마다 경쾌하게 해당 빈 버퍼에 덮어씁니다.
3. **비파괴적 덧셈 렌더링 (Non-Destructive Rendering):** GPU 렌더링 셰이더(`GaussianSplatting.hlsl`)가 화면을 송출하기 나노초 직전, 압축을 깔끔하게 전부 풀어낸 뒤 가상의 쾌적한 3D 도화지에 위치시킬 때, **아까 CPU가 건네준 메모장의 '이동 지시사항'만을 산술적으로 살짝 더하고 곱해 최종 화면으로 바로 출력**합니다.

### 🌟 달성한 성과 및 장점
* **무한한 조작의 자유 (글리치 100% 해소):** 이미 압축 규칙이 해제된 최종 스크린 좌표 위에서 오프셋만을 더하기 때문에, 점들을 청크 박스 밖 1억 km 밖으로 밀어내거나 1만 배 키워도 절대 벽에 부딪히거나 찌그러지지 않습니다. 완벽하게 부드러운 궤적 이동이 실행됩니다.
* **초당 60 프레임 최상급 퍼포먼스:** 무거운 Compute Shader 파이프라인을 가동할 필요가 전혀 없고 압축 부담이 사라졌으므로, C# CPU 연산만으로도 모바일에서 거뜬한 실시간 퍼포먼스를 뽑아냅니다.
* **비파괴적 상태 유지:** 원본 `.asset` 도면은 단 1비트의 손상도 입지 않고 유리 전시관 밑에 영구 보존됩니다. 애니메이터가 지시사항 전달을 끊는 순간 0.01초 만에 정상 구도(오리지널 씬)로 순식간에 복귀합니다.
* **컬러/투명도 라이브 이펙트 성공:** 골치 아픈 텍스처 접근 권한 문제를 회피하여 렌더링 막바지 수학적 결과물에 컬러 틴트를 입혀, 점진적으로 색상을 바꾸거나 투명하게 사라지게 만드는 트랜지션 효과를 완벽하게 구동 가능해졌습니다.

---

## 4. 부가 연구: 대역폭 최적화를 위한 실시간 LOD 스트리밍
(이전 논의 사항: 스트리밍 대비)
* 대용량 데이터를 실시간 렌더링 타임(Runtime)에 곧바로 네트워크로 파싱하는 것은 구조상 불가능에 가깝기에, 오프라인(에디터)에서 고품질(`VeryHigh`)과 저용량/가벼운 버전(`Mobile_High`)으로 각각의 에셋을 미리 굽는 전략을 채택했습니다. 
* 이를 위해 수십 개의 `.ply` 더미를 한 번에 저해상도로 깎아 다운그레이드시키는 **`BatchGaussianImporter` 자동화 스크립트 툴**을 내부적으로 제작 및 도입했습니다. 
* 런타임 게임 씬 내에서는 `AddressablesStreamingPlayer` 구조를 응용하여 현재 네트워크 대역폭(Bandwidth) 상태를 체크하여, 무리를 주지 않기 위해 고해상도 자산과 저품질 자산을 핫스왑(Hot Swap) 형식으로 다이나믹하게 스위칭할 수 있는 뼈대 구조를 성공적으로 연구해 두었습니다.

---
### 문서를 발표 목적에 맞게 활용하는 법:
1. **서론:** `.ply` 데이터를 Unity로 변환하는 핵심 양자화 구조 설명.
2. **배경과 문제:** 압축 한계(1.0 바운딩 박스) 때문에 일어난 '바둑판 찌그러짐(글리치)' 현상 시연.
3. **핵심 돌파구:** 원본 자체 변조가 왜 위험한지 그 한계를 꼬집고, 투명한 도화지 필터를 덮어 씌워 더하는 "Live Object Injection(옵션 B)"의 세련된 프로그래밍 구조 자랑.
4. **결과:** 성능 최적화(FPS 확보)와 컬러 트랜지션 성공, 그리고 부가 LOD 스트리밍 채택 구조 언급.
