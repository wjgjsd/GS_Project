# Gaussian Splatting: 원본 .ply 파일에서 유니티용 .asset 으로 구워지는 "상세 변환 파이프라인" 가이드

에디터에서 `GaussianSplatAssetCreator.cs`가 외부 `.ply` 원본 파일을 유니티 전용 최적화 포맷인 단일 덩어리 `.asset` 파일로 완성해 내는 핵심 원리는 상상 이상으로 정교하고 우악스러운 **"공간 정렬 및 양자화(Quantization)" 압축** 기술입니다. 

그 내부의 섬세한 파이프라인 과정을 7개의 단계로 상세히 정리합니다.

## [1단계] 원본 파싱 및 램(RAM) 적재 (Parsing & Loading)
가장 먼저 파일 리더를 담당하는 스크립트(`GaussianFileReader`)가 수 기가바이트의 `.ply` 바이너리 원본 데이터를 스캔합니다. 
수백만 개의 개별 점(Splat)들이 각각 가지고 있는 엄청난 수치 데이터들, 즉 물리적인 속성(위치 벡터, 방향 회전을 위한 쿼터니언, XYZ 크기 스케일, 매 점마다 45개의 거대한 float 자리를 차지하는 구면조화함수 빛 컬러와 불투명도 등)을 일단 날것의 형태 그대로 C#의 거대한 1D 데이터 배열(RAM) 위로 전부 복사해서 올려놓습니다.

## [2단계] 모튼 정렬 기술 (Morton Reordering) - 💡가장 핵심적인 렌더링 최적화
수십 수백만 개의 점들이 파일에서 입력된 순서표대로만 구속되어 메모리 배열에 뒤죽박죽으로 섞여 들어가 있으면, GPU가 이를 화면에 시각적으로 그릴 때 메모리의 이곳저곳을 마구잡이로 무작위 접근하며 뛰어다녀야 해서 메모리 캐시 성능이 최악의 상태로 박살납니다.

이 병목을 부수기 위해, 씬 전체 좌표계를 3D 격자 스캐닝 곡선 기법인 **"3D Morton Code(모튼 코드)" 알고리즘**으로 재계산합니다.
월드 공간 상에서 **서로 물리적인 위치 거리가 매우 밀접하고 가까운 점(Splat)들이, 실제 컴퓨터 내부의 순차적인 메모리 1D 배열(Array) 상에서도 반드시 1번 방, 2번 방, 3번 방처럼 서로 이웃한 인접 공간 위치에 들어가도록 전체 배열 인덱스를 공간 물리 기반 기준으로 싹 한 번 갈아엎어 정렬(Sorting)** 해버리는 가장 중요한 과정입니다!

## [3단계] 청크 단위 분할 및 로컬 공간 정규화 (Chunking & Normalization)
모튼 정렬이 끝나 이제 물리적으로 뺵빽하게 함께 모여있는 거대한 점들의 배열을 앞에서부터 정확히 **256개 단위의 소대 규모로 싹둑싹둑 잘라내어 "청크(Chunk)" 조직**으로 쪼개어 나눕니다. (이미 앞서 모튼 정렬을 완벽하게 마쳤으므로, 이 256개의 점 뭉텅이들은 화면상에 한 번에 손쉽게 뭉쳐서 그릴 수 있게 매우 조밀한 집단 단위로 이루어져 있습니다.)

잘라낸 256개 묶음마다 가장 바깥쪽 점들을 타이트하게 에워싸는 최소/최대 바운딩 박스를 계산합니다 (`SplatChunkInfo`).
그리고 나면 원래 Splat들이 보유하고 있던 거대한 무한 3D 우주 좌표 체계를 통째로 압축해 지워버리고, 오직 **각 점이 자신이 속박되어 갇힌 256개짜리 청크 박스 안에서만 가지는 극소 상대 비율 좌표 (0.000 ~ 1.000)** 로 그 모든 값들을 깎아서 변환해버립니다. (이를 맞추기 위해 크기 파라미터나, 전체 색상, 환경 빛 반사 데이터도 전부 비율 상대 범위로 같이 세탁됩니다.)

## [4단계] 구면조화함수(SH) 15차원 스칼라 색상 클러스터링 (K-Means Clustering)
이 렌더링 시스템에서 빛의 사각을 계산하는 데이터(Spherical Harmonics)가 전체 GPU 용량의 80% 이상을 잡아먹는 거대한 주범입니다. 
에셋 크리에이터에서 최고 품질(VeryHigh) 옵션 모드를 쓰지 않았다면, 전체 씬의 모든 점들이 지닌 빛의 속성 데이터들을 머신러닝 알고리즘의 일종인 **"K-Means 군집화 알고리즘"**으로 클러스터링합니다.

"유사한 색상과 빛이 부딪히는 굴절 특성"을 가진 수천 수만 개의 Splat 집단을 색연필 통 하나로 묶어 '공통 색상 스펙트럼 도서관 딕셔너리(Dictionary)'를 딱 한 권 공통으로 구축한 다음, 수백만 개의 모든 Splat 데이터 테이블은 해당 45개의 거대한 float 데이터 변수 뭉치를 싹 다 휴지통에 버립니다. 그리고 오직 그 도서관 목록의 **"N번째 색연필 번호(단 2바이트 인덱스)"** 코드표만을 메모장처럼 단순하게 저장하여 용량을 상상 이상으로 과격하게 폭력적으로 압축해 줄입니다.

## [5단계] 극한의 정수형 양자화 변환 코딩 (Quantization Encoding)
이 모든 상대적인 비율의 실수형 0~1 배열들을 비트 마스킹(Bit Masking) 기법을 이용해 강제로 정수형(int, uint) 숫자들에 구겨 쑤셔 넣습니다.
* **위치 데이터 (Norm11)**: 박스 안의 `0.0~1.0` 위치들을 정수형 수백 단위 숫자로 반올림 소수 연산하여 각각 11, 10, 11단위의 단 32비트 안에 모두 때려 넣습니다.
* **회전 각도 (Smallest 3)**: 기준이 되는 4개의 쿼터니언(float4) 축 값 중 제일 거대한 방향 1개를 쓰레기통에 버린 뒤, 나머지 3개의 각도 숫자만 빈틈이 가장 작은 10비트 정수형 공간 안에 밀어넣어 조립식 4바이트 블럭으로 만들어 압축합니다.
* **컬러 데이터 (Norm8x4)**: 0~1의 RGBA 비율 세팅을 0~255 정수로 바꾼 뒤, 1칸 단위당 4바이트가 필요한 이 시스템의 엄청나게 비대한 2D 텍스처(Texture2D 이미지) 픽셀 포맷 칩셋으로 모두 뒤바꿔버립니다.

## [6단계] 바이트 배열 직렬화(Serialize) 및 TextAsset 하드 디스크 구워내기
이렇게 극한의 인공 압축 과정이 끝난 거대한 덩어리 배열들을 이제 쪼개서 분류합니다: 
(1) 위치 데이터들을 묶은 배열 (`*pos.bytes`)
(2) 회전, 크기들을 전부 압축해 모은 배열 (`*oth.bytes`)
(3) 앞서 큰 그림을 그렸던 메인 텍스처 색상 데이터 (`*col.bytes`)
(4) 256개 단위의 거대 바운딩 청크 박스 좌표계들의 모음들 (`*chk.bytes`)
(5) 빛의 반사 도서관 클러스터링 묶음 목록 (`*shs.bytes`)

나누어진 이 5개의 쪼개진 순수한 마이크로 C# 바이트 데이터 배열을 하드 디스크에 유니티가 바이너리 파일을 직접 텍스트처럼 내부적으로 취급해 인식하는 **`TextAsset`** 묶음 보관소 파일로 무식하게 쭈르륵 써냅니다(Write File). 

## [7단계] 마침내 생명을 얻는 최종 `.asset` 통합본 (ScriptableObject) 생성 
이제 아무런 내용물이 안 들어있는 빈 깡통뿐인 설계도 형체의 **`GaussianSplatAsset`** (ScriptableObject 스크립터블 오브젝트) 유니티 전용 에셋을 하나 만듭니다.

이 깡통의 각각의 데이터 속성 슬롯 연결망 칸(`m_PosData`, `m_ColorData` ...)들에 방금 전 하드 드라이브 디스크에 분리해서 구워낸 5개의 TextAsset 데이터 파일(`*.bytes`) 조각들을 각각 일대일 링크시켜서 연결합니다.
마지막으로 C# 유니티 엔진 고유 접근 API인 `AssetDatabase.CreateAsset()` 메소드와 `AssetDatabase.SaveAssets()` 함수를 강제로 때려서 우리가 인스펙터 구조창에서 가장 눈에 익숙하게 바라보는 통합된 **`.asset`** 완전체 오리지널 데이터 파일로 합법적인 도장을 찍고 비로소 하나의 생명으로 탄생시키게 됩니다!

---

💡 **핵심 시사점 정리 (Why GPU?)**

만약 유저님이 개발하실 때 하드 디스크상에 굳어진 **오프라인 원본 저 `.asset` 파일 자체의 위치 내용을 완벽하게(글리치 현상이나 찰흙화 없이) 실시간으로 깔끔하게 이동 변경**하려 드신다면, 앞서 말한 저 **미친 듯이 복잡한 역순 정규화 프로세스 과정 (압축 일일이 다 풀기 -> 월드 거대 3D 좌표 스케일로 부풀려 복구하기 -> 목표 대상 오프셋 변경점 찾아서 더하기 -> 256개 단위로 청크 박스 바운더리 전부 재쪼개기 -> 모튼 정렬 스캐닝 알고리즘 다시 하기 -> 소수점을 정수로 다시 양자화 압축 뭉개기 -> 다시 쪼개서 하드 디스크에 파일 저장하고 재로드 쓰기)** 이 무한 궤도를 일일이 모두 코드로 구현하여 사용자가 입력을 바꿀 때마다 매 1프레임 안에서 수백만 번 한꺼번에 풀스윙으로 다 돌려야 합니다. 당연히 게임 성능이 1초에 1프레임도 안 돌아가는 완전히 멈춰버리는 렉 지옥의 재앙 상태에 빠져 치명적으로 비효율적입니다.

이 사실은, 지난 과제에서 구축했던 **"왜 원본 오프라인 데이터(.asset) 편집보다, GPU 램 메모리(Compute Shader) VRAM 접근 방식이 1순위의 압도적인 아키텍처 해결책인가?"**를 완벽하게 역으로 해답을 증명해주고 있습니다. 

유틸리티 컴퓨터 연산 스크립트 기반 구조인(`CSApplyDelta` 데이터 수정기)는 다행히도 시스템이 저렇게 수백 번 넘게 꼬여있는 **복잡한 압축 해제 뭉치들을 렌더링 화면을 송출하기 극초단 직전 타이밍에 VRAM 위에서 GPU 코어가 가장 먼저 풀어헤친 초당 수천 프레임의 연산 월드 3D 깔끔한 좌표 스크래치 패드(`_SplatPos`) 위에서, 단순히 + 기호(오프셋 Delta Position 값)만을 산술적으로 가볍게 더해주면 그 더해진 결과 위치가 즉각적으로 눈에 반영**되는 컴퓨터 공학상 게임 엔진에서 구현하는 가장 이상성 짙은 "동적 렌더링 실시간 데이터 수정 파이프라인 구조(Live Modification Pipeline)"로 이미 완벽하게 탑재가 가능하게 설계되어 있었던 것입니다!
